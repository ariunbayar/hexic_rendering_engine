// Generated by CoffeeScript 1.4.0
(function() {
  var Cell, Engine, Graphics, Helpers, Settings;

  if (typeof d3 === "undefined") {
    console.log("d3.js is not included. Consult with d3js.org");
    return;
  }

  Graphics = {
    createSVG: function(container_selector, width, height) {
      return d3.select(container_selector).append('svg').attr('width', width).attr('height', height);
    },
    drawContainer: function(svg, x, y) {
      return svg.append('g').attr('transform', "translate(" + x + ", " + y + ")");
    },
    drawArc: function(container, inner_radius, outer_radius, fill_percent, color) {
      return container.append('path').attr('fill', color).attr('d', Helpers.arc.getD(0, 2 * Math.PI * fill_percent, inner_radius, outer_radius));
    },
    drawCircle: function(container, r, border, colors) {
      return container.append('circle').attr('r', r).attr('stroke', colors.stroke).attr('stroke-width', border).attr('fill', colors.fill);
    },
    drawHexagon: function(container, r, border, colors) {
      return container.append("svg:polygon").attr('fill', colors.fill).attr('stroke', colors.stroke).attr('stroke-width', border).style('stroke-linejoin', 'round').attr("points", Helpers.polygon.getPoints(0, 0, 6, r));
    },
    drawArrow: function(container, colors) {
      var g;
      g = container.append('g');
      g.append("svg:polyline").attr('stroke-width', 1).attr("points", "0,0 10,10 0,5 -10,10 0,0").attr('transform', "translate(0, -32)").style('visibility', 'hidden');
      return g;
    },
    changeHexagonColor: function(el, colors) {
      var el_parent;
      el_parent = d3.select(el[0][0].parentNode);
      return el_parent.transition().attr('fill-opacity', 0).attr('stroke-opacity', 0).each('end', function() {
        return el.attr('fill', colors.fill).attr('stroke', colors.stroke);
      }).transition().attr('fill-opacity', 1).attr('stroke-opacity', 1);
    },
    changeArcColor: function(el, color) {
      return el.attr('fill', color);
    },
    changeCircleColor: function(el, colors) {
      return el.attr('stroke', colors.stroke).attr('fill', colors.fill);
    },
    changeCircleRadius: function(el, radius) {
      return el.transition().duration(750).attr('r', radius).ease('elastic');
    },
    changeArcRadius: function(el, inner_radius, outer_radius, progress) {
      return el.attr('d', Helpers.arc.getD(0, 2 * Math.PI * progress, inner_radius, outer_radius));
    },
    changeArrowDirection: function(el, direction, colors) {
      el.attr('transform', Helpers.arrow.getAngleBy(direction));
      return el.select('polyline').attr('display', "block").attr('fill', colors.fill).attr('stroke', colors.stroke).style('visibility', 'visible');
    },
    mouseoverHexagon: function(el) {
      return el.transition().style('stroke-width', 3).style('fill-opacity', .5);
    },
    mouseoutHexagon: function(el) {
      return el.transition().style('stroke-width', 0).style('fill-opacity', 1);
    }
  };

  Helpers = {
    arc: {
      getD: function(start_angle, end_angle, inner_radius, outer_radius) {
        return d3.svg.arc().startAngle(start_angle).innerRadius(inner_radius).outerRadius(outer_radius).endAngle(end_angle);
      }
    },
    polygon: {
      getStarPoints: function(centerX, centerY, arms, outerRadius, innerRadius) {
        var angle, currX, currY, i, r, results, _i, _ref;
        results = "";
        angle = Math.PI / arms;
        for (i = _i = 0, _ref = 2 * arms; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          r = (i & 1) === 0 ? outerRadius : innerRadius;
          currX = centerX + Math.cos(i * angle + angle) * r;
          currY = centerY + Math.sin(i * angle + angle) * r;
          if (i === 0) {
            results = currX + "," + currY;
          } else {
            results += ", " + currX + "," + currY;
          }
        }
        return results;
      },
      getPoints: function(centerX, centerY, arms, radius) {
        var angle, currX, currY, i, results, _i;
        results = "";
        angle = Math.PI * 2 / arms;
        for (i = _i = 0; 0 <= arms ? _i < arms : _i > arms; i = 0 <= arms ? ++_i : --_i) {
          currX = centerX + Math.cos(i * angle + angle / 2) * radius;
          currY = centerY + Math.sin(i * angle + angle / 2) * radius;
          if (i === 0) {
            results = currX + "," + currY;
          } else {
            results += ", " + currX + "," + currY;
          }
        }
        return results;
      }
    },
    arrow: {
      getAngleBy: function(direction) {
        var degrees;
        if (direction === 1) {
          degrees = " rotate(330)";
        }
        if (direction === 2) {
          degrees = " rotate(35)";
        }
        if (direction === 3) {
          degrees = " rotate(90)";
        }
        if (direction === 4) {
          degrees = " rotate(150)";
        }
        if (direction === 5) {
          degrees = " rotate(210)";
        }
        if (direction === 6) {
          degrees = " rotate(270)";
        }
        return degrees;
      }
    },
    colors: function(r, g, b) {
      return {
        stroke: "rgba(" + r + ", " + g + ", " + b + ", 1)",
        fill: "rgba(" + r + ", " + g + ", " + b + ", .3)"
      };
    },
    coords: function(position) {
      var coord_x, coord_y;
      coord_x = position.x * Settings.offset_x + Settings.board_offset_x;
      if (position.y % 2) {
        coord_x += Settings.offset_x / 2;
      }
      coord_y = position.y * Settings.offset_y + Settings.board_offset_y;
      return {
        x: coord_x,
        y: coord_y
      };
    },
    getRadiusAndProgressFor: function(power) {
      var level, perimeter, progress, r, r_arc, r_circle, radius_diff;
      level = 0;
      radius_diff = Settings.radiuses[1] - Settings.radiuses[0];
      while (true) {
        if (!(level in Settings.radiuses)) {
          power = 0;
          break;
        }
        r = Settings.radiuses[level];
        perimeter = 2 * Math.PI * r;
        if (power < perimeter) {
          break;
        }
        power -= perimeter;
        level++;
      }
      r_arc = r;
      r_circle = r - radius_diff > 0 ? r - radius_diff : null;
      progress = power / perimeter;
      return [r_circle, r_arc, progress];
    }
  };

  Settings = {
    radius: 29,
    radiuses: [3, 6, 9, 12, 15, 18, 21, 24, 27],
    border: 0,
    offset_x: 2 * 30 * Math.sin(Math.PI / 3),
    offset_y: 2 * 30 * Math.sin(Math.PI / 3) * Math.sin(Math.PI / 3),
    board_offset_x: 30,
    board_offset_y: 30,
    colors: {
      red: Helpers.colors(255, 0, 0),
      blue: Helpers.colors(0, 0, 255),
      gray: Helpers.colors(127, 127, 127),
      inactive: Helpers.colors(220, 220, 220)
    }
  };

  Cell = Backbone.Model.extend({
    defaults: {
      el_svg: null,
      el_container: null,
      el_hexagon: null,
      el_circle: null,
      el_arc: null,
      el_arrow: null,
      position: null,
      colors: Settings.colors.inactive,
      power: null,
      direction: null,
      neighbours: []
    },
    initialize: function() {
      var border, colors, coords, el_arrow, el_container, el_hexagon, el_svg, radius, self;
      coords = Helpers.coords(this.get('position'));
      radius = Settings.radius;
      border = Settings.border;
      colors = this.get('colors');
      el_svg = this.get('el_svg');
      el_container = Graphics.drawContainer(el_svg, coords.x, coords.y);
      el_hexagon = Graphics.drawHexagon(el_container, radius, border, colors);
      el_arrow = Graphics.drawArrow(el_container, colors);
      this.set('el_container', el_container);
      this.set('el_arrow', el_arrow);
      this.set('el_hexagon', el_hexagon);
      this.on('change:power', this.powerChanged, this);
      this.on('change:colors', this.colorsChanged, this);
      this.on('change:direction', this.directionChanged, this);
      self = this;
      el_container.on('mouseover', function() {
        var cell, _i, _len, _ref, _results;
        Graphics.mouseoverHexagon(el_hexagon);
        _ref = self.get('neighbours');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cell = _ref[_i];
          _results.push(Graphics.mouseoverHexagon(cell.get('el_hexagon')));
        }
        return _results;
      });
      return el_container.on('mouseout', function() {
        var cell, _i, _len, _ref, _results;
        Graphics.mouseoutHexagon(el_hexagon);
        _ref = self.get('neighbours');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          cell = _ref[_i];
          _results.push(Graphics.mouseoutHexagon(cell.get('el_hexagon')));
        }
        return _results;
      });
    },
    colorsChanged: function() {
      var c, colors, el_arc, el_circle, el_hexagon;
      colors = this.get('colors');
      el_hexagon = this.get('el_hexagon');
      el_circle = this.get('el_circle');
      el_arc = this.get('el_arc');
      if (el_hexagon) {
        Graphics.changeHexagonColor(el_hexagon, colors);
      }
      if (el_circle) {
        c = {
          stroke: colors.fill,
          fill: colors.stroke
        };
        Graphics.changeCircleColor(el_circle, c);
      }
      if (el_arc) {
        return Graphics.changeArcColor(el_arc, colors.fill);
      }
    },
    powerChanged: function() {
      var border, c, colors, coords, el_arc, el_circle, el_container, power, progress, r_arc, r_circle, _ref;
      power = this.get('power');
      if (power === null) {
        return;
      }
      coords = Helpers.coords(this.get('position'));
      el_container = this.get('el_container');
      colors = this.get('colors');
      border = Settings.border;
      _ref = Helpers.getRadiusAndProgressFor(power), r_circle = _ref[0], r_arc = _ref[1], progress = _ref[2];
      el_arc = this.get('el_arc');
      if (el_arc === null) {
        el_arc = Graphics.drawArc(el_container, 0, r_arc, progress, colors.fill);
        this.set('el_arc', el_arc);
      } else {
        Graphics.changeArcRadius(el_arc, 0, r_arc, progress);
      }
      if (r_circle === null) {
        return;
      }
      el_circle = this.get('el_circle');
      if (el_circle === null) {
        c = {
          stroke: colors.fill,
          fill: colors.stroke
        };
        el_circle = Graphics.drawCircle(el_container, r_circle, border, c);
        return this.set('el_circle', el_circle);
      } else {
        return Graphics.changeCircleRadius(el_circle, r_circle);
      }
    },
    directionChanged: function() {
      var colors, direction, el_arrow;
      colors = this.get('colors');
      direction = this.get('direction');
      el_arrow = this.get('el_arrow');
      if (direction) {
        return Graphics.changeArrowDirection(el_arrow, direction, colors);
      }
    }
  });

  Engine = function() {
    this.board = [];
    this.svg = null;
    this.updateBoard = function(board) {
      var direction, has_cell_at, neighbours, power, shift, user_id, x, y, _ref;
      if (this.svg === null) {
        this.svg = Graphics.createSVG('body', 500, 400);
      }
      for (y in board) {
        if (!(y in this.board)) {
          this.board[y] = [];
        }
        for (x in board[y]) {
          _ref = board[y][x], user_id = _ref[0], power = _ref[1], direction = _ref[2];
          if (!(x in this.board[y])) {
            this.board[y][x] = this._newCellAt(x, y);
          }
          this.board[y][x].set('colors', this._getColor(user_id));
          this.board[y][x].set('power', power);
          this.board[y][x].set('direction', direction);
        }
      }
      has_cell_at = function(y, x) {
        if (y in board) {
          return x in board[y];
        }
        return false;
      };
      for (y in board) {
        for (x in board[y]) {
          y = parseInt(y);
          x = parseInt(x);
          shift = y % 2 ? 1 : 0;
          neighbours = [];
          if (has_cell_at(y - 1, x - 1 + shift)) {
            neighbours.push(this.board[y - 1][x - 1 + shift]);
          }
          if (has_cell_at(y - 1, x + shift)) {
            neighbours.push(this.board[y - 1][x + shift]);
          }
          if (has_cell_at(y, x + 1)) {
            neighbours.push(this.board[y][x + 1]);
          }
          if (has_cell_at(y + 1, x - 1 + shift)) {
            neighbours.push(this.board[y + 1][x - 1 + shift]);
          }
          if (has_cell_at(y + 1, x + shift)) {
            neighbours.push(this.board[y + 1][x + shift]);
          }
          if (has_cell_at(y, x - 1)) {
            neighbours.push(this.board[y][x - 1]);
          }
          this.board[y][x].set('neighbours', neighbours);
        }
      }
    };
    this._newCellAt = function(x, y) {
      return new Cell({
        el_svg: this.svg,
        position: {
          x: x,
          y: y
        }
      });
    };
    this._getColor = function(user_id) {
      var i, num_users;
      if (!('_colors_assigned' in this)) {
        this._colors_assigned = {};
        this._colors_left = [Settings.colors.blue, Settings.colors.red];
      }
      if (user_id === 0) {
        return Settings.colors.gray;
      }
      if (user_id in this._colors_assigned) {
        return this._colors_assigned[user_id];
      }
      if (this._colors_left.length) {
        return this._colors_assigned[user_id] = this._colors_left.shift();
      }
      num_users = ((function() {
        var _results;
        _results = [];
        for (i in this._colors_assigned) {
          _results.push(i);
        }
        return _results;
      }).call(this)).length + 1;
      throw "not enough colors for " + num_users + " users";
    };
  };

  window.Engine = Engine;

}).call(this);
